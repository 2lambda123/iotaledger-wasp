// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

package cliqueDist

import (
	"errors"
	"fmt"

	"github.com/iotaledger/hive.go/core/marshalutil"
	"github.com/iotaledger/wasp/packages/cryptolib"
	"github.com/iotaledger/wasp/packages/gpa"
	"github.com/iotaledger/wasp/packages/hashing"
)

// Generated by the dst node, if it receives the query, then signature will be set.
// And generated by the src node, if check fails.
type LinkStatus struct {
	srcPubKey  *cryptolib.PublicKey
	dstPubKey  *cryptolib.PublicKey
	signature  []byte // failReason == nil --> Sign([sessionID, srcPubKey, dstPubKey], dstPriKey)
	failReason error  // failReason != nil --> Sign([sessionID, srcPubKey, failReason], srcPriKey)
}

func NewLinkStatusOK(sessionID hashing.HashValue, src *cryptolib.PublicKey, dst *cryptolib.KeyPair) *LinkStatus {
	sigMsg := append(sessionID.Bytes(), src.AsBytes()...)
	sigMsg = append(sigMsg, dst.GetPublicKey().AsBytes()...)
	return &LinkStatus{
		srcPubKey:  src,
		dstPubKey:  dst.GetPublicKey(),
		signature:  dst.GetPrivateKey().Sign(sigMsg),
		failReason: nil,
	}
}

func newLinkStatusFailed(sessionID hashing.HashValue, src *cryptolib.KeyPair, dst *cryptolib.PublicKey, failReason error) *LinkStatus {
	sigMsg := append(sessionID.Bytes(), src.GetPublicKey().AsBytes()...)
	sigMsg = append(sigMsg, []byte(failReason.Error())...)
	return &LinkStatus{
		srcPubKey:  src.GetPublicKey(),
		dstPubKey:  dst,
		signature:  src.GetPrivateKey().Sign(sigMsg),
		failReason: failReason,
	}
}

func NewLinkStatusFromMarshalUtil(mu *marshalutil.MarshalUtil) (*LinkStatus, error) {
	var err error
	var u16 uint16
	ls := &LinkStatus{}
	if ls.srcPubKey, err = cryptolib.NewPublicKeyFromMarshalUtil(mu); err != nil {
		return nil, fmt.Errorf("cannot unmarshal LinkStatus.srcPubKey: %w", err)
	}
	if ls.dstPubKey, err = cryptolib.NewPublicKeyFromMarshalUtil(mu); err != nil {
		return nil, fmt.Errorf("cannot unmarshal LinkStatus.dstPubKey: %w", err)
	}
	if u16, err = mu.ReadUint16(); err != nil {
		return nil, fmt.Errorf("cannot unmarshal LinkStatus.signatureLen: %w", err)
	}
	if ls.signature, err = mu.ReadBytes(int(u16)); err != nil {
		return nil, fmt.Errorf("cannot unmarshal LinkStatus.signature: %w", err)
	}
	var success bool
	if success, err = mu.ReadBool(); err != nil {
		return nil, fmt.Errorf("cannot unmarshal LinkStatus.success: %w", err)
	}
	if success {
		ls.failReason = nil
	} else {
		if u16, err = mu.ReadUint16(); err != nil {
			return nil, fmt.Errorf("cannot unmarshal LinkStatus.failReasonLen: %w", err)
		}
		var failReasonBytes []byte
		if failReasonBytes, err = mu.ReadBytes(int(u16)); err != nil {
			return nil, fmt.Errorf("cannot unmarshal LinkStatus.failReasonBytes: %w", err)
		}
		ls.failReason = errors.New(string(failReasonBytes))
	}
	return ls, nil
}

func (ls *LinkStatus) Bytes() []byte {
	mu := marshalutil.New()
	mu.Write(ls.srcPubKey)
	mu.Write(ls.dstPubKey)
	mu.WriteUint16(uint16(len(ls.signature)))
	mu.WriteBytes(ls.signature)
	if ls.failReason == nil {
		mu.WriteBool(true)
	} else {
		mu.WriteBool(false)
		failReasonBytes := []byte(ls.failReason.Error())
		mu.WriteUint16(uint16(len(failReasonBytes)))
		mu.WriteBytes(failReasonBytes)
	}
	return mu.Bytes()
}

func (ls *LinkStatus) SrcPubKey() *cryptolib.PublicKey {
	return ls.srcPubKey
}

func (ls *LinkStatus) DstPubKey() *cryptolib.PublicKey {
	return ls.dstPubKey
}

func (ls *LinkStatus) FailReason() error {
	return ls.failReason
}

func (ls *LinkStatus) Validate(sessionID hashing.HashValue) bool {
	if ls.failReason == nil {
		sigMsg := append(sessionID.Bytes(), ls.srcPubKey.AsBytes()...)
		sigMsg = append(sigMsg, ls.dstPubKey.AsBytes()...)
		return ls.dstPubKey.Verify(sigMsg, ls.signature)
	}
	sigMsg := append(sessionID.Bytes(), ls.srcPubKey.AsBytes()...)
	sigMsg = append(sigMsg, []byte(ls.failReason.Error())...)
	return ls.srcPubKey.Verify(sigMsg, ls.signature)
}

func (ls *LinkStatus) ShortString() string {
	return fmt.Sprintf("{LinkStatus, src=%v, dst=%v, err=%v}",
		gpa.NodeIDFromPublicKey(ls.srcPubKey).ShortString(),
		gpa.NodeIDFromPublicKey(ls.dstPubKey).ShortString(),
		ls.failReason,
	)
}
