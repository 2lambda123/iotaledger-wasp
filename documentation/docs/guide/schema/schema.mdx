---
description: We use _schema definition files_ to generate code for smart contracts, which clearly define all aspects of a smart contract that should be known to its users.
image: /img/logo/WASP_logo_dark.png
keywords:
- code generation
- schema tool
- automatic
- repetitive code fragments
- robust
- schema definition file
- explanation
---

# Smart Contract Schema Tool

Smart contracts need to be very robust, and the setup code of every smart contract must follow strict rules: you want to assure that certain functions can only be called by specific entities, and that function parameters values have been properly checked before their usage. As the generic nature of WasmLib allows for a lot of flexibility, it also provides a lot of opportunities to make mistakes, the issue that is only amplified by repetitive coding tasks.

One way to increase robustness is to use a code generator. It only needs to be debugged once to produce an accurate and trustworthy code forever, so you could easily regenerate your code every time you introduce changes into your smart contract's interface. It can also generate wrapper code which limits the access rights of your function, which would catch certain kinds of errors even before your smart contract compiles. Finally, code generators could translate the same schema into multiple languages, which makes it easier to maintain in a cross-platform environment. For example, you could use the same schema to generate smart contract code for a Rust-based virtual machine and for a TypeScript-based user application.

As we were working on first demo smart contracts for WasmLib, we have found some similar tasks for which we were writing the same code again and again:

* Setting up the `on_load` function and then keeping it up to date.
* Checking function access rights.
* Verifying function parameter types.
* Verifying the presence of mandatory function parameters.
* Setting up access to the state, params, and results maps.
* Defining common strings as constants.

To facilitate the code generation, we decided to use a _schema definition file_ for smart contracts. All aspects of a smart contract that should be known by someone who wants to use the contract are clearly defined within that file. This schema definition file then becomes the source of truth for how the smart contract works.

The schema definition file defines things like the [state](state.mdx) variables that the smart contract uses, the [Funcs](funcs.mdx) and [Views](views.mdx) that the contract implements, the [access rights](access.mdx) for each function, the [input parameters](params.mdx) and [output results](results.mdx) for each function, and additional data structures that the contract uses.

With detailed schema information readily available in a single location, the schema tool can go beyond simple generation of repetitive code fragments. It can use the schema information to generate interfaces for functions, parameters, results, and the state which use strict compile-time type checking. This makes it much harder for a dev to introduce an error.

The schema tool also has enough information to let you generate constants for key strings, which prevents typos, and it can also precalculate some values like `Hname`-type values and store them as constant instead of forcing the code to recalculate them every time.

Similarly, since you know all static keys that are going to be used by the smart contract in advance, you can now generate code that will negotiate the corresponding key IDs with the host only once in the `on_load` function, and cache those values for use in future function calls.

The previous two optimizations mean that the code becomes both simpler and more efficient. Note that all improvements are independent of the target language.

## Future Improvements

Future additions that we envision for the schema tool are the automatic generation of smart contract interface classes to use with client side JavaScript, and automatic generation of a web API for smart contracts. The schema definition file can also provide a starting point for other tooling, for example for a tool that automatically audits a smart contract.