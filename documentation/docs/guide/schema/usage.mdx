---
description: The `schema` tool will assist in creating a smart contract unobtrusively as possible.
image: /img/logo/WASP_logo_dark.png
keywords:
- functions
- schema tool
- definition file
- Rust
- Go
- init
- json
- yml
- usage
- how to
---
import Tabs from "@theme/Tabs"
import TabItem from "@theme/TabItem"

# Using the Schema Tool

This section explains how to create a smart contract from scratch.

## Naming Conventions

The schema tool expects you to follow a few naming conventions:

* For smart contract names, use PascalCase like in `MySmartContract`.
* For types, use PascalCase like in `MyType`.
* For variable names, use camelCase like in `myVariable`.
* For function names, use camelCase like in `myFunction`.

Note that the schema tool will still generate folders and files with their names in lowercase. 

## Creating a New Schema

You need to create a folder that would contain all your smart contracts, each in its own subfolder. Navigate to that folder and initialize your first smart contract: 

```shell
schema -init MySmartContract
```

This command generates a basic schema for a smart contract with a name `MySmartContract`. It creates a new `mysmartcontract` subfolder and a basic YAML schema definition file within it. 

If you prefer JSON over YAML, you can specify it through the `-type` optional parameter:

```shell
schema -init MySmartContract -type=json
```

The generated schema definition file looks like this:

<Tabs defaultValue="yaml"
      values={[
          {label: 'schema.yaml', value: 'yaml'},
          {label: 'schema.json', value: 'json'},
      ]}>

<TabItem value="json">

```json
{
  "name": "MySmartContract",
  "description": "MySmartContract description",
  "events": {}
  "structs": {},
  "typedefs": {},
  "state": {
    "owner": "AgentID // current owner of this smart contract"
  },
  "funcs": {
    "init": {
      "params": {
        "owner": "AgentID? // optional owner of this smart contract"
      }
    },
    "setOwner": {
      "access": "owner // current owner of this smart contract",
      "params": {
        "owner": "AgentID // new owner of this smart contract"
      }
    }
  },
  "views": {
    "getOwner": {
      "results": {
        "owner": "AgentID // current owner of this smart contract"
      }
    }
  }
}
```

</TabItem>
<TabItem value="yaml">

```yaml
name: MySmartContract
description: MySmartContract description
events: {}
structs: {}
typedefs: {}
state:
  owner: AgentID // current owner of this smart contract
funcs:
  init:
    params:
      owner: AgentID? // optional owner of this smart contract
  setOwner:
    access: owner // current owner of this smart contract
    params:
      owner: AgentID // new owner of this smart contract
views:
  getOwner:
    results:
      owner: AgentID // current owner of this smart contract
```

</TabItem>
</Tabs>

The schema definition file has been pre-populated with all sections that you might need, and some functions that allow you to maintain the ownership of the smart contract. Now you can edit this file to reflect the requirements of your smart contract. For now, you can change the value of the `description` field to some different string.

## Generating the Source Code

Once you are done modifying the schema file, navigate to the `mysmartcontract` subfolder and run the schema tool to generate the smart contract code in your preferred language:

<Tabs defaultValue="go"
      groupId="language"
      values={[
          {label: 'Go', value: 'go'},
          {label: 'Rust', value: 'rust'},
          {label: 'TypeScript', value: 'ts'},
      ]}>

<TabItem value="go">

```shell
schema -go
```

</TabItem>
<TabItem value="rust">

```shell
schema -rust
```

</TabItem>
<TabItem value="ts">

```shell
schema -ts
```

</TabItem>
</Tabs>

You can combine these options to generate the source code for two or more languages:

```shell
schema -rust -go
```

Note that the schema tool determines the type of the schema definition file (YAML or JSON) by its file extension.

The schema tool will generate a complete set of source files for the desired language. 

The generated code is practically identical for all languages. Here is an example of a `mysmartcontract.xx` file for every language:

<Tabs defaultValue="go"
      groupId="language"
      values={[
          {label: 'Go', value: 'go'},
          {label: 'Rust', value: 'rust'},
          {label: 'TypeScript', value: 'ts'},
      ]}>

<TabItem value="go">

```go
package mysmartcontract

import "github.com/iotaledger/wasp/packages/wasmvm/wasmlib"


func funcInit(ctx wasmlib.ScFuncContext, f *InitContext) {
    if f.Params.Owner().Exists() {
        f.State.Owner().SetValue(f.Params.Owner().Value())
        return
    }
    f.State.Owner().SetValue(ctx.ContractCreator())
}

func funcSetOwner(ctx wasmlib.ScFuncContext, f *SetOwnerContext) {
    f.State.Owner().SetValue(f.Params.Owner().Value())
}

func viewGetOwner(ctx wasmlib.ScViewContext, f *GetOwnerContext) {
    f.Results.Owner().SetValue(f.State.Owner().Value())
}
```

</TabItem>
<TabItem value="rust">

```rust
use wasmlib::*;

use crate::*;

pub fn func_init(ctx: &ScFuncContext, f: &InitContext) {
    if f.params.owner().exists() {
        f.state.owner().set_value(&f.params.owner().value());
        return;
    }
    f.state.owner().set_value(&ctx.contract_creator());
}

pub fn func_set_owner(_ctx: &ScFuncContext, f: &SetOwnerContext) {
    f.state.owner().set_value(&f.params.owner().value());
}

pub fn view_get_owner(_ctx: &ScViewContext, f: &GetOwnerContext) {
    f.results.owner().set_value(&f.state.owner().value());
}
```

</TabItem>
<TabItem value="ts">

```ts
import * as wasmlib from "wasmlib"
import * as sc from "./index";

export function funcInit(ctx: wasmlib.ScFuncContext, f: sc.InitContext): void {
    if (f.params.owner().exists()) {
        f.state.owner().setValue(f.params.owner().value());
        return;
    }
    f.state.owner().setValue(ctx.contractCreator());
}

export function funcSetOwner(ctx: wasmlib.ScFuncContext, f: sc.SetOwnerContext): void {
    f.state.owner().setValue(f.params.owner().value());
}

export function viewGetOwner(ctx: wasmlib.ScViewContext, f: sc.GetOwnerContext): void {
    f.results.owner().setValue(f.state.owner().value());
}
```

</TabItem>
</Tabs>

The schema tool has generated a working version of functions that are used to maintain the smart contract owner. This implementation suffices for most cases.

You can set up your build environment to run the code generation command every time it detects a change in the schema file. This way you would not need to run this command every time manually.

By default, the schema tool ignores subsequent code generation commands if it does not detect any change in the schema file. If, say, your code project got corrupted and you need to regenerate the source files, you can override this behavior by adding the `-force` option:

<Tabs defaultValue="go"
      groupId="language"
      values={[
          {label: 'Go', value: 'go'},
          {label: 'Rust', value: 'rust'},
          {label: 'TypeScript', value: 'ts'},
      ]}>

<TabItem value="go">

```shell
schema -go -force
```

</TabItem>
<TabItem value="rust">

```shell
schema -rust -force
```

</TabItem>
<TabItem value="ts">

```shell
schema -ts -force
```

</TabItem>
</Tabs>

## Compiling

To compile your smart contract project into a Wasp code file, follow these instructions:

<Tabs defaultValue="go"
      groupId="language"
      values={[
          {label: 'Go', value: 'go'},
          {label: 'Rust', value: 'rust'},
          {label: 'TypeScript', value: 'ts'},
      ]}>

<TabItem value="go">

```shell
tinygo build -target wasm wasmmain/main.go
```

This will use the Go source files in the current folder. The only file in this folder that you should edit manually is `mysmartcontract.go`. All other files are regenerated and overwritten each time you run the schema tool.

</TabItem>
<TabItem value="rust">

Before compiling, modify the `Cargo.toml` file to your needs, and add the new project to a Rust workspace if necessary. `Cargo.toml` will not be regenerated once it already exists. 

Then compile the code as follows:

```shell
wasm-pack build
```

This will use the `src` subfolder that contains all Rust source files. The only file in this folder that you should edit manually is `mysmartcontract.rs`. All other files are regenerated and overwritten each time you run the schema tool.

</TabItem>
<TabItem value="ts">

```shell
asc lib.ts --binaryFile output_ts.wasm --lib path/to/node_modules
```

This will use the TypeScript source files in the current folder. The only file in this folder that you should edit manually is `mysmartcontract.ts`. All other files are regenerated and overwritten each time you run the schema tool.

</TabItem>
</Tabs>

## Video Tutorial

<iframe width="560" height="315" src="https://www.youtube.com/embed/aTwXHuzwqZ0" title="Deploying with Schema Tool" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### Creating Smart Contracts using AssemblyScript

<iframe width="560" height="315" src="https://www.youtube.com/embed/P5HMgmY3DMM" title="Creating Smart Contracts using AssemblyScript" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
